function [p_sample_cone,p_sample_sl,index_act] =...
                        check_3dgenpts(rinc,thetainc,nzsec,chinc,...
                                       n_sd,Z_sd,sddepth)
%Build samples to be used in hom and nonhom. (Geom stored in script!)
%   rinc,thetainc are var steps/increments used to build sample points within a single
%   chamber, nzsec is the number of sections along z w/in a chamber while chinc says 
%   drop the samples in every chinc^th chamber, eg 2nd, 3rd, 25th chamber, etc. Additionally, 
%   the code generates extra sample points near the activation site in both
%   p_sample_cone and p_sample_sl. index_act gives the first point index at
%   and after the points now belong to the activation site samples. 


disp(['Warning: Node_Prism_Lists generated by hom assembla ' ...
      'should be included in this folder'])
disp(['so that the right samples for ' ...
      'the sliver are taken. You should generate this'])
disp(['data file before running a sample of nonhom'])
disp(['If you changed the number of chambers update this in'...
     ' check_3dgenpts.'])
pause

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Write the data
R_b = 3;
R_t = 1;
H   = 15;
nu  = 1;
n_chambers = 100;
epsilon_0 = H/((1+nu)*(n_chambers-1));
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%Take uniform samples throughout the cone
                   
z_sample_chamber = nu*epsilon_0/nzsec*(...
                   cumsum(ones(1,nzsec+1))-1);
               
               
%Sample points scaled to disc radius R_t               
p_sample_cross_section = R_t*check_genpts(rinc,thetainc)';

p_sample_cone = zeros(3,(floor(n_chambers/chinc)-1)*...
                       size(z_sample_chamber,2)*...
                       size(p_sample_cross_section,2));
                   


for I=1:floor(n_chambers/chinc)-1 %-1 to not deal with final .5*nu*eps0
    
    z0 = .5*nu*epsilon_0+(I-1)*(1+nu)*epsilon_0*chinc+...
            epsilon_0; %Bottom z-height of interdiscal being sampled
    samplez = z0+z_sample_chamber;
    
    %Build all pairings for z_0 and p_sample_cross_section
    pairings = zeros(3,size(samplez,2)*size(p_sample_cross_section,2));
    for J=1:size(samplez,2)
        for K=1:size(p_sample_cross_section,2)
            pairings(:,(J-1)*size(p_sample_cross_section,2)+K) =...
                                  [p_sample_cross_section(:,K);samplez(J)];    
        end
    end
    
    %Write into p_sample_cone
    p_sample_cone(:,...
                 (I-1)*size(samplez,2)*size(p_sample_cross_section,2)+1:...
                     I*size(samplez,2)*size(p_sample_cross_section,2))=...
                 pairings;
end
disp('Built uniform interior cone sample points');
%Add in the activation sample points in cone interior

index_act = size(p_sample_cone,2)+1;  %First activation associated
                                      %sample point in p_sample_cone
                                      
%Obtain the Z-heights in the nonhom code of the activation
%sites.
[Z_SD,~] = check_findactch(n_sd,Z_sd,...Need to get sites that nonhom
                           R_b,R_t,H,nu,n_chambers,...actually used
                           epsilon_0);
%Extract z-heights sufficiently far above and below activation.
for D=-sddepth:sddepth
    Z_SD = [Z_SD Z_SD + D*(epsilon_0+nu*epsilon_0)];
end
Z_SD = unique(Z_SD);  %Get unique z-heights
%Repeat the loop design from uniform samples just now done at activation
%too.  
augment = zeros(3,size(Z_SD,2)*...
                  size(z_sample_chamber,2)*...
                  size(p_sample_cross_section,2));
for I=1:size(Z_SD,2)
    
    samplez = Z_SD(I)+z_sample_chamber; 
    %Build all pairings for z_0 and p_sample_cross_section
    pairings = zeros(3,size(samplez,2)*size(p_sample_cross_section,2));
    for J=1:size(samplez,2)
        for K=1:size(p_sample_cross_section,2)
            pairings(:,(J-1)*size(p_sample_cross_section,2)+K) =...
                                  [p_sample_cross_section(:,K);samplez(J)];    
        end
    end
    
    %Write into p_sample_cone
    augment(:,...
           (I-1)*size(samplez,2)*size(p_sample_cross_section,2)+1:...
           I*size(samplez,2)*size(p_sample_cross_section,2))=...
           pairings;
end
p_sample_cone = [p_sample_cone augment];

%Rescale each point from radius R_t to actual cone radius
%lambda = @(z) R_b/R_t-(R_b-R_t)/(R_t*H)*z;
%for I=1:size(p_sample_cone,2)
%    p_sample_cone(:,I) = [lambda(p_sample_cone(3,I))*p_sample_cone(1:2,I);... Might be better to NOT do this 
%                          p_sample_cone(3,I)];                                %bc findpr will have to undo
%end
%clear lambda
disp('Built interior cone activation samples');
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Take samples in the sliver.  Simpler because no missing gaps.
%We use the sliver nodes from hom as the base list then translate
%outward from these along the horizontal radius.
load('Node_Prism_Lists','p_3dsl')

nradslinc = 5;
disp(['In the sliver there are ' num2str(nradslinc) ' samples '...
      'along each ray. Change this in check_3dgenpts at var nradslinc']);
pause
p_sample_sl = cell(1,nradslinc);
erho = [p_3dsl(1,:)./( p_3dsl(1,:).^2+p_3dsl(2,:).^2 ).^(1/2);...
        p_3dsl(2,:)./( p_3dsl(1,:).^2+p_3dsl(2,:).^2 ).^(1/2);...
        zeros(2,size(p_3dsl,2))]; %Zeros are for z value and gdl index
shift = cumsum(ones(1,nradslinc))-1;
shift = epsilon_0/nradslinc*shift;
for i=1:nradslinc
    p_sample_sl{i} = p_3dsl+shift(i)*erho;
end

%%%%%%%%%%%%%%%%*************************************************************************
%n_ztics = (floor(n_chambers/chinc)-1)*nzsec;
%if n_ztics == 0
%    error('n_ztics isnt computing correctly');
%end
%ztic = H/n_ztics;
%
%p_sample_slcross = check_p_sample_slcross(R_t,epsilon_0,rinc,thetainc);
%p_sample_slcross = p_sample_slcross';
%p_sample_sl = zeros(3,...
%                      (floor(H/ztic)-2)*...
%                       size(p_sample_slcross,2));
%for I = 2:floor(H/ztic)-1
%    p_sample_sl(:,...
%        (I-2)*size(p_sample_slcross,2)+1:...
%        (I-1)*size(p_sample_slcross,2))=...
%    [p_sample_slcross ;...
%    repmat(I*ztic,1,size(p_sample_slcross,2))];
%end
%disp('Built uniform sliver samples')
%
%Now sample at activation
%index_act = [index_act size(p_sample_sl,2)+1];
%augment = zeros(3,...
%                size(Z_sd,2)*size(p_sample_slcross,2)...
%                );
%for I = 1:size(Z_sd,2)
%    augment(:,...
%        (I-1)*size(p_sample_slcross,2)+1:...
%        (I)*size(p_sample_slcross,2))=...
%    [p_sample_slcross ; ...
%     repmat(Z_sd(I),1,size(p_sample_slcross,2))];
%end
%
%p_sample_sl = [p_sample_sl augment];
end

function pair_tree = check_p_sample_slcross(R,eps,Rinc,Thetainc)
%These live in annulus of width eps between radius [R,R+eps]. The angles
%live between [-pi/2,pi/2] which to get the hom code's points needs to be
%shifted to [0,pi]. Output is two columns with x and y coordinates.

%Redefine so integer many points. The n is # of intervals
nR = floor(eps/Rinc);
if nR == 0
    nR = 1;
end
Rinc = eps/nR;

nTheta = floor(pi/Thetainc);
Thetainc = pi/nTheta;

pair_tree = lexB([nR nTheta]);

pair_tree = [R+Rinc*(pair_tree(:,1)-1) -pi/2+Thetainc*(pair_tree(:,2)-1)];

%Map from polar into x-y coordinates
pair_tree = [pair_tree(:,1).*cos(pair_tree(:,2)) ...
             pair_tree(:,1).*sin(pair_tree(:,2))];
end

function [ Z_sd,z_scaling ] = check_findactch(n_sd,Z_sd,...
                                                R_b,R_t,H,nu,n_chambers,...
                                                epsilon_0)
%W/geom (in file) and sp discs, find bottom face of act site and scaling.
%   Find the base and tops of chambers closest to the activation
%   sites given by Z_sd in data. This code taken from genmesh 
%   lines 419-438. The output is the left ends of 
%   .5I {[C I] ... [C I]} C .5I sequence.
%   Z_sd = [.25*H .33*H .64*H .78*H]; 

disc = [1 0];                                                               %This section should make Giovanni's  
disc = repmat(disc,1,n_chambers-2);                                         %sd2sez code unnecessary?
disc = [0 disc 1 0];
disc = epsilon_0*disc;                  %Thickness of the C's

inter= [0 1];
inter= repmat(inter,1,n_chambers-2);
inter= [.5 inter 0 .5];
inter= nu*epsilon_0*inter;              %Thickness of the I's.

z_ticr= cumsum(inter+disc);             %Compute right ends along z-
                                        %axis of the .5I {[C I]} C
                                        %.5I sequence.  
z_ticl= z_ticr - (inter+disc);          %Compute left endpoint of 
                                        %intervals by subtracting
                                        %out their lengths.

z_ticr= z_ticr(2*cumsum(...             %I chambers are at odd 
        ones(1,n_chambers))-1);         %positions and are 
                                        %n_chambers many of them.
z_ticl= z_ticl(2*cumsum(...             %Just grabbed their left
          ones(1,n_chambers))-1);       %endpoint.
      
                                        
ram  = [zeros(1,2*n_chambers);...               %We'll join
        repmat(cumsum(ones(1,n_chambers)),1,2)];%z_ticl/r-Z_sd
found= zeros(1,n_sd);                           %in 1st row and
                                                %record in 2nd
                                                %what chamber is.
    
for i=1:n_sd                            %Find the chamber with 
    ram(1,:) = [abs(z_ticr-Z_sd(i))...  %closest face by 
                abs(z_ticl-Z_sd(i))];   %computing distance from
                                        %both faces of chamber
    ram      = sortrows(ram');          %by magnitude of distance
    ram      = ram';                    %and sorting by that value.
                                        %The other row says which
                                        %chamber have.
    
    found(i) = ram(2,1);                %Found is the index of the
                                        %chamber closest.
                                        
                                        %Reset for the next cycle.
    ram(2,:) = repmat(cumsum(ones(1,n_chambers)),1,2);
                                        
end

Z_sd = z_ticl(found);                   %By default we will place 
                                        %the isomerization on the
                                        %bottom face of the found
                                        %interdiscal chamber.

Lambda  = @(z) R_b/R_t - (R_b-R_t)/(H*R_t).*z;
z_scaling= arrayfun(Lambda,Z_sd);       %Compute cone scaling at each 
                                        %special disk height.

end

