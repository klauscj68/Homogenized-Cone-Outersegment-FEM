% Programma per la soluzione del problema della diffusione sui dischi attivati del bastoncello con incisure
% Code for solving the diffusion problem on activated disks of rod with incisures
function main_id

clear all

close all

clc

% % % profile on

% add to path the commo files
path('../common',path);
path('../elements',path);

% read data
% data input
[R_b, R_t, H, n_sez, flag_geom_sp, dz_0, ...
    theta_in,theta_fin,...    
    n_sd, Z_sd, ...
    taglia, tol_R, tol_angle, ...
    n_ref_cyto, n_ref_id, metodo_cyto, metodo_id, ...
    solver, theta, alpha, tol_fix, norma_inf, peak_delta, ...
    t_fin, n_step_t, downsample, ...
    plot_mesh, plot_num, plot_niagara, plot_pool , inspect, ...
    u_tent, v_tent, tol_stat, ...
    flag_model, flag_model_disc, flag_Ca_clamp, ...
    mode_time, mode_space, n_step_R, mu, lambda, ...
    nu_RE, nu_RG, cc_R_st, D_R_st, ...
    n_Phi, Phi, random_location, ...
    k_GE, cc_G_st, D_G_st, ...
    k_hyd, PDE_s, k_st, ...
    cc_E_st, D_E_st, k_E, ...
    MC_disk, ...
    n_sample, ...
    epsilon_0, nu, sigma, ...
    cc_u, kk_u, cc_v, kk_v, ...
    alpha_max, alpha_min, m_cyc, k_cyc, ...
    flag_ch,B_ca, F, j_cg_max, f_ca, m_cg, K_cg, ...
    j_ex_sat, K_ex]=data;


% mesh construction
[n_pd, n_int_pd, n_tri, n_sl, n_fo,  ...
         sl2pd, fo2pd, pd2int_pd, p_pd, t_pd, ...
         n_pd_sd, n_int_pd_sd, n_tri_sd, n_sl_sd, n_fo_sd, ...
         sl2pd_sd, fo2pd_sd, pd2int_pd_sd, p_pd_sd, t_pd_sd, ...
         Z_s, sd2sez, z_scaling]=...
     genemesh(R_b, R_t, H, theta_in, theta_fin, n_sez, flag_geom_sp, dz_0, ...
     n_sd, Z_sd, ...
     taglia, tol_R, tol_angle, n_ref_cyto, n_ref_id, ...
     plot_mesh, plot_num, inspect);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%load('E_st_nonhom')                                                                       %
%p_pd_sd = p_pd(1:2,:)*R_b; %Renormalize to R_b radius
%t_pd_sd = t_pd(1:3,:);
%z_scaling(sd2sez(1)) = z_scaling/R_b; %So that R_b times this is hom's z_scaling = activation radius when R_t = 1
%n_pd_sd = size(p_pd_sd,2);
%n_tri_sd= size(t_pd_sd,2);                                                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% % random walk
% confronto_MC_PDE(n_ipd_id, p_ipd_id, n_tri_id, t_ipd_id, ...
%      n_sd, n_inc, inc, ...
%      cc_R_st, D_R_st, ...
%      n_Phi, Phi, ...
%      tau, mode_time, ...
%      peak_delta, R, ...
%      inspect, plot_pool, plot_niagara, ...
%      t_fin, n_step_t, metodo_id, solver);
% stop



% Compute global matrices K and M for the disc diffusion problem on each
% activated disc

K=cell(1,n_sd);
M=cell(1,n_sd);
Z_scaling = zeros(n_sd,1);

for cont=1:n_sd
    [K{cont}, M{cont}] = assembla_sd(n_pd_sd, n_tri_sd, p_pd_sd*z_scaling(sd2sez(cont)), t_pd_sd);
    Z_scaling(cont) = z_scaling(sd2sez(cont));
end


% inizializza E_st e massa_E_st
E_st=cell(1,n_sd);
massa_E_st=cell(1,n_sd);
for d=1:n_sd
    E_st{d}=zeros(n_pd,n_sample,n_step_t/downsample+1);
    massa_E_st{d}=zeros(n_sample,n_step_t/downsample+1);
    massa_R_st{d}=zeros(n_sample,n_step_t/downsample+1,n_step_R);
end

% ciclo sui campioni random
for samp=1:n_sample

    fprintf('Campione %4i di %4i\n',samp,n_sample);
    
    % choose at random the locations of photoisomerizations, if requested
    if random_location
        for s=1:n_sd
            % rho is distributed in such a way that 
            % [rho*cos(beta);rho*sin(beta) is uniformly distributed on the disc
            rho=R_b*z_scaling(sd2sez(s))*sqrt(rand(1,n_Phi(s)));
            beta=2*pi*rand(1,n_Phi(s));
            % update rho,beta into Phi{s}
            Phi{s}(1:2,:)=[rho; beta];
        end
    end

    % problema della creazione di R* ed E^* sui dischi speciali incisi
    % creation of R* and E* on incised special disk
    if MC_disk
        % metodo Monte Carlo semplificato
        % tasso di creazione di E*, nu_RE, da parte di R* dipendente solo dallo stato di R*
        % simplifie Monte Carlo method
        % rate of production of E*, vu_RE, depending only on the state of R*
        [time, R_st_sd, E_st_sd]=diffusione_ipd_MC(...
            n_ipd_id , n_tri_id , p_ipd_id, t_ipd_id, ...
            n_sd, n_inc, inc, ...
            D_E_st, D_R_st, ...
            n_step_R, nu_RE, k_E, tau, equal_step, mode_time, ...
            n_Phi, Phi, ...
            peak_delta, R,  ...
            plot_pool , inspect, ...
            t_fin, n_step_t);

    %     % import Monte-Carlo results for the problem of production and diffusion of E_st (E*) in the incised special discs
    %     [time, E_st_A]=diffusione_ipd_MC_A(R, n_pd, n_tri, p_pd, t_pd, ...
    %         n_sd, n_inc, inc, R, ...
    %         t_fin, n_step_t, plot_mesh, inspect);
    else
        % integrazione nel tempo del problema di creazione e diffusione di E_st (E*) nei dischi speciali incisi
        % time integration of the problem of production and diffusion of E_st (E*) in the incised special discs
        [time, R_st_sd, G_st_sd, E_st_sd]=diffusione_sd_PDE(...
            n_pd_sd , n_tri_sd , p_pd_sd, t_pd_sd, ...
            n_sd, flag_model, flag_model_disc, ...
            cc_R_st, D_R_st, cc_G_st, D_G_st, cc_E_st, D_E_st, ...
            n_step_R, mu, lambda, nu_RE, nu_RG, ...
            k_E, k_GE, PDE_s, mode_time, mode_space, ...
            n_Phi, Phi, ...
            peak_delta, R_b, z_scaling, sd2sez,  ...
            plot_niagara, plot_pool , inspect, ...
            t_fin, n_step_t, metodo_id, solver, theta, alpha, tol_fix);
    end

    
    % maps the solution of the problem for E_st in the special discs on the
    % non refined discs
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    if n_ref_cyto<n_ref_id                                                                %
        [E_st_sample]=diffusione_sd2pd(n_pd, p_pd, p_pd_sd, t_pd_sd, ...
            n_sd, n_step_t, R_b, E_st_sd);
    end                                                                                   %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % % %     disp(['esperimento ',num2str(samp)])
    % salva
    for d=1:n_sd
        % compute the mass of E_st_sd, 
        massa_E_st{d}(samp,:)=ones(1,n_pd_sd )*M{d}*(E_st_sd{d}(1:downsample:n_step_t+1,:))';
        % compute the mass of R_st
        for cont=1:n_step_R
            massa_R_st{d}(samp,:,cont)=ones(1,n_pd_sd )*M{d}*(R_st_sd{d}(1:downsample:n_step_t+1,:,cont))';
        end
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
         %in E_st viene memorizzata la E_st cucita (E_st_sample)                             %          
        E_st{d}(:,samp,:)=(E_st_sample{d}(1:downsample:n_step_t+1,:))';                      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    end

% % % massa_E_st{1}(samp,:)
% % % [ones(1,n_ipd_id )*M*R_st_id{1}';...
% % %     ones(1,n_ipd_id )*M*G_st_id{1}';...
% % %     ones(1,n_ipd_id )*M*E_st_id{1}']
save advance samp
end
    

% salva su disco la distribuzione decimata di E_st, la sua massa
% ed i tempi corrispondenti
time_downsample=time(1:downsample:n_step_t+1);
save('E_st_sd','E_st_sd', 'massa_E_st',  'time_downsample',...
     'M'... These are only for the sd not the volume
     )
save('Mesh_SD','p_pd_sd','t_pd_sd','Z_scaling')%"
save('E_st', 'E_st','massa_E_st',  'time_downsample')

% % % profile viewer

return
