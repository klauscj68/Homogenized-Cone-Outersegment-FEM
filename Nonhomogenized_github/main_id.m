function main_id(p_3d,f_3d)
%Compute E* on special disks generated by photon isomerizations.
%   is n_pd_cyto right here?

% Grab the data 
[ R_b,R_t,H,theta_in,theta_fin,epsilon_0,nu,sigma,n_chambers,...
           dz_0,n_sd,Z_sd,flag_geom_sp, ...
           taglia,n_sez,tol_R,tol_angle,n_ref_cyto,n_ref_id,...
           metodo_cyto,...
           flag_model,flag_model_disc,...
           cc_R_st, D_R_st, cc_G_st, D_G_st, cc_E_st, D_E_st,...
           n_step_R,mu,lambda,nu_RE,nu_RG,...
           k_E, k_GE, PDE_s, mode_time, mode_space, n_sample,...
           n_Phi, Phi,...
           norma_inf,...
           peak_delta,...
           plot_niagara, plot_pool, inspect,...
           t_fin, n_step_t, metodo_id, solver, downsample,...
           u_tent,v_tent,tol_stat,...
           theta, alpha, tol_fix,...
           beta_dark,k_st, B_ca, F, f_ca,...
           cc_u,kk_u,cc_v,kk_v,...
           alpha_max,alpha_min,m_cyc,k_cyc,...
           j_cg_max,m_cg,K_cg,...
           j_ex_sat,K_ex] = data;

% Build prototype mesh for activated disk. Recall that the
% prototype disc has radius R_t. This routine is not time
% expensive or if it were, it would be better to only call
% it once between this and genmesh.
[ p_pd,e_pd,t_pd,e_arcpd,n_pd,n_ed,n_tri,n_arced,...
           tri_disc,tri_sl,...
           edgarc1,edgarc2,edgarc3,edgarc4,edgarc5,...
           vert_disc,vert_sl,...
           vertarc1,vertarc2,vertarc3,vertarc4,vertarc5]...
           = genmesh_cross(R_b,R_t,H,theta_in,theta_fin,...
                           epsilon_0,nu,sigma,...
                           taglia,tol_R,tol_angle,n_ref_id);

% Trim the mesh down so it is now just the disc part
% without the sliver.  We first find which edges 
% have both vertices in the disc and delete others.
% We renumber the nodes in the disc according to 
% their position in the trimmed nodes list. After, we
% apply a reindexing function reind so that edge and
% triangle lists are rewritten with respect to the 
% vertex list.
ram   = ismember(e_pd(1,:),vert_disc).*... %Find edges with both
        ismember(e_pd(2,:),vert_disc);     %vertices in the 
                                           %disc.
ed_disc=find(ram);  

p_pd = p_pd(:,vert_disc);              %Vertices, edges, and
e_pd = e_pd(:,ed_disc);                %triangle lists trimmed
t_pd = t_pd(:,tri_disc);               %to disc mesh.   

n_pd = size(vert_disc,1);              %Update numbers of 
n_tri = size(t_pd,2);                  %nodes, triangles,                 
n_ed  = size(ed_disc,2);               %and edges.
                                     
reind = @(i) find(vert_disc == i);          %Reindex the lists to
e_pd(1:2,:) = arrayfun(reind,e_pd(1:2,:));  %reflect the new disc
t_pd(1:3,:) = arrayfun(reind,t_pd(1:3,:));  %vertex ordering.
                           
% Find the base and tops of chambers closest to the activation
% sites given by Z_sd in data. 

[Z_sd,z_scaling] = find_actch;
save('Z_sd','Z_sd')
                                        
% Compute global matrices K and M for the 
% disc diffusion problem on an activated
% disc.

K = cell(1,n_sd);
M = cell(1,n_sd);

% Observe assembla_sd is unmodified from
% Giovanni's original script. Thus, p_pd
% -- rescaled by cone dilation -- is all
% vertices even with sliver BUT t_pd only
% is triangles in the disc, so only these
% indices are seen in assembly and there
% n_pd many of these coming from n_tri
% (in the true disc part of cross 
% section).
for cont=1:n_sd
    [K{cont}, M{cont}] = assembla_sd(n_pd,...
                         n_tri, p_pd(1:2,:)*z_scaling(cont),...
                         t_pd(1:3,:));
end

% Unlike Giovanni's code, I am only 
% programming the heat kernel diffusion
% of isomerization part of code, not the
% random walk?
for samp=1:n_sample                                                         %This loop probably not needed for us.
    fprintf('Campione %4i di %4i\n',samp,n_sample);

% Does rho_sq need a z-scaling?                                             %Does this need a z-scaling?  
[time, R_st_sd, G_st_sd, E_st_sd]=diffusione_sd_PDE(...
            n_pd , n_tri , p_pd(1:2,:), t_pd(1:3,:), ...
            R_t, n_sd, flag_model, flag_model_disc, ...
            cc_R_st, D_R_st, cc_G_st, D_G_st, cc_E_st, D_E_st, ...
            n_step_R, mu, lambda, nu_RE, nu_RG, ...
            k_E, k_GE, PDE_s, mode_time, mode_space, ...
            n_Phi, Phi, ...
            peak_delta, R_b, z_scaling,  ...                               %Dropped the sd2sez input
            plot_niagara, plot_pool , inspect, ...
            t_fin, n_step_t, metodo_id, solver, ...
            theta, alpha, tol_fix);

% maps the solution of the problem for E_st in the special discs on the
% now refined discs.
% Probably need to fix the p_pd_sd part.
    if n_ref_cyto<n_ref_id
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        %Rebuild the cytosol disc cross section mesh
        [ p_pd_cyto,e_pd_cyto,t_pd_cyto,~,...
          n_pd_cyto,n_ed_cyto,n_tri_cyto,~,...
          tri_disc_cyto,tri_sl_cyto,...
          ~,~,~,~,~,...
           vert_disc_cyto,vert_sl_cyto,...
           ~,~,~,~,~]...
           = genmesh_cross(R_b,R_t,H,theta_in,theta_fin,...
                           epsilon_0,nu,sigma,...
                           taglia,tol_R,tol_angle,n_ref_cyto);

        % Trim the mesh down so it is now just the disc part
        % without the sliver.  We first find which edges 
        % have both vertices in disc and then delete them.
        % We renumber the nodes in the sliver according to 
        % their position in the trimmed nodes list. After, we
        % apply a reindexing function reind so that edge and
        % triangle lists are rewritten with respect to the 
        % vertex list.
        ram   = ismember(e_pd_cyto(1,:),vert_disc_cyto).*... %Find edges with both
        ismember(e_pd_cyto(2,:),vert_disc_cyto);     %vertices in the 
                                           %disc.
        ed_disc_cyto=find(ram);  

        p_pd_cyto = p_pd_cyto(:,vert_disc_cyto);    %Vertices, edges, and
        e_pd_cyto = e_pd_cyto(:,ed_disc_cyto);      %triangle lists trimmed
        t_pd_cyto = t_pd_cyto(:,tri_disc_cyto);     %to disc mesh.   

        n_pd_cyto = size(vert_disc_cyto,1);              %Update numbers of 
        n_tri_cyto = size(t_pd_cyto,2);                  %nodes, triangles,                 
        n_ed_cyto  = size(ed_disc_cyto,2);               %and edges.
                                     
        reind = @(i) find(vert_disc_cyto == i);          %Reindex the lists to
        e_pd_cyto(1:2,:) = arrayfun(reind,e_pd_cyto(1:2,:));  %reflect the new disc
        t_pd_cyto(1:3,:) = arrayfun(reind,t_pd_cyto(1:3,:));  %vertex ordering.
        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        % Not clear to me if this needs a z-scaling? The find_tri call
        % may be ok because that might be independent of homothety.                         % If E_st_sd came from something with scaling, can we get away here not using one?%
        %Best way to check is compare the E_st above with E_st_sample below
        %but E_st_sample trisurf'd over the z_scaled actual/physical disc.
        [E_st_sample]=diffusione_sd2pd(n_pd_cyto, p_pd_cyto(1:2,:),...                      % Need a z_scaling? Don't think so because
            p_pd(1:2,:), t_pd(1:3,:), ...  %This was originally n_pd, p_pd, p_pd_sd,t_pd_sd % the only call using nodes is to find tri
            n_sd, n_step_t, R_t, E_st_sd);                                                                                                            % which the found triangles indices should
    end                                                                                     % be invariant under homothety... unless the
    % Initialize E*, mass of E*&R*.                                                         % the call of R_t breaks scaling symmetry?
    E_st=cell(1,n_sd);                                                                      % Don't think so bc it just defined the error tol
    mass_E_st=cell(1,n_sd);
    for d=1:n_sd
        E_st{d}=zeros(n_pd_cyto,n_sample,n_step_t/downsample+1);
        mass_E_st{d}=zeros(n_sample,n_step_t/downsample+1);
        mass_R_st{d}=zeros(n_sample,n_step_t/downsample+1,n_step_R);
    end

    % salva(=save)
    %%%%%%%% This part new
    n_p3d = size(p_3d,2);
    % For mapping E_st onto the volume degrees of freedom
    [~,dof_sd] = sd2sez(p_3d,f_3d,p_pd_cyto(1:2,:));
    E_st_sp    = cell(1,n_sd);
    %%%%%%%%

    for d=1:n_sd
        % compute the mass of E_st_sd, 
        massa_E_st{d}(samp,:)=ones(1,n_pd )*M{d}*(E_st_sd{d}(1:downsample:n_step_t+1,:))';
        % compute the mass of R_st
        for cont=1:n_step_R
        massa_R_st{d}(samp,:,cont)=ones(1,n_pd )*M{d}*(R_st_sd{d}(1:downsample:n_step_t+1,:,cont))';
        end
        % in E_st viene memorizzata la E_st cucita (E_st_sample)
        E_st{d}(:,samp,:)=(E_st_sample{d}(1:downsample:n_step_t+1,:))';      % The size is n_pd_cyto by n_sample by n_timepts
        %%%%%%%% This part new
        [nrows,ncols] = size(squeeze(E_st{d}(:,samp,:)));
        if nrows ~= n_pd_cyto
            error('Sparse part of main_id is off')
        end
        E_st_sp{d}= sparse(n_p3d,ncols);
        for theta = 1:ncols %samp was middle index below
            E_st_sp{d}(:,theta) = sparse(dof_sd{d},ones(n_pd_cyto,1),...
                                        E_st{d}(:,samp,theta),n_p3d,1);   
        end
        %%%%%%%%
    end
    clear E_st
    E_st = E_st_sp;
    clear E_st_sp
save advance samp
end
% salva su disco la distribuzione decimata di E_st, la sua massa
% ed i tempi corrispondenti
time_downsample=time(1:downsample:n_step_t+1);
save('E_st','E_st', 'massa_E_st',  'time_downsample',...
     'E_st_sd','M','p_pd','t_pd','z_scaling')
end

function [tri,dof_sd] =...
          sd2sez(p_3d,f_3d,p_cyto) %p_pd_cyto(1:2,:) is what need
   %Output the triangular faces belonging to each special disc.  Note that
   %tri is a 1 by n_sd cell whose entries are 3 by n_tridsic matrices
   %listing the triangular elements of this special disc with respect to
   %p_3d. Also output the dof_sd node indices, w.r.t p_3d but ordered like
   %p_cyto as. p_cyto has the radius Rt while, p_3d has the cone geometry
   %radius.
n_pcyto = size(p_cyto,2);     %number dof in sd
[ ~,~,~,~,~,epsilon_0,nu,~,~,~,n_sd,~,~,~,n_sez,~,...
           ~] = data;
tri  = cell(1,n_sd);          %Store triangles
dof_sd = cell(1,n_sd);        %Store where nodes belong

[Z_sd,~]=find_actch;
tol_z = nu*epsilon_0/(4*n_sez);%Height of smallest interdiscal chamber
                               %chamber is nu*eps0/2 which is broken up
                               %into n_sez.  If take half of the former
                               %divided by latter, no disc faces should
                               %be that close to the true faces. 
                               
% Reorganize p_cyto into a KD tree w.r.t x-y
% coordinates.  When match the p_3d nodes to
% p_cyto, we'll cycle over p_3d candidate nodes
% and compare to p_cyto by scanning over their
% KD tree. We must also rescale p_3d to the 
% common domain of p_cyto, so that we need
% only build 1 KD tree.
% Read geometric parameters
[ R_b,R_t,H,~,...
    ~] = data;
lambda = R_b/R_t - (R_b-R_t)/(H*R_t)*Z_sd;  %Scaling factor
lambdainv = 1./lambda;
                                            
KD_pcyto = KDTreeSearcher(p_cyto');         %p_cyto lives in disc R_t
disp('KD Tree Assembled')
for i=1:n_sd
   % Find faces in a disc and which are tolerance
   % close to Z_sd(i)
   ram = f_3d(4,:) == 0;         %Horizontal faces
   ram = ram.*(f_3d(5,:)==-1);   %Belonging to discs
   ram = ram.*...                %Inside z-tolerance
       (abs(p_3d(3,f_3d(1,:))...
        -Z_sd(i))<= tol_z);
   faces = find(ram);
   clear ram
   tri{i} = f_3d(1:3,faces);
   clear faces
   % Find where the nodes belong in relation to 
   % the tri{d} list. 
   ram = unique(tri{i}(:)); %All nodes in sd indexed 
                            %like dof_vol list.
   cand = p_3d(1:2,ram);    %Need to find where each column
                            %p_cyto is closest to which column
                            % cand. column of cand matches
                            % ram(column) index.
                            
   cand = lambdainv(i)*cand;%Rescale to domain of KD tree
   volissd = knnsearch(KD_pcyto,cand'); %Match vol ind to closest
                                        %sd node index, meaning 
                                        %vol ram(i) is sd volissd(i), ie
                                        %Ind -------> dof_sd
                                        %|   volissd
                                        %|ram
                                        %v
                                        %dof_vol
                                        %So map should be ram\circ
                                        %volissd^(-1)
   sdtovol = @(k) ram(find(volissd == k));
   dof_sd{i} = arrayfun(sdtovol,cumsum(ones(n_pcyto,1)));
end
end



